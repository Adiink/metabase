import fs from "node:fs/promises";
import path from "path";

import glob from "glob";

const DYNAMIC_IMPORT_LOCALE_REGEX = /\bimport\((.*?)\)/g;
const DYNAMIC_IMPORT_LOCALE_FUNCTION_NAME = "mb_importLocale";

const normalizeLocaleName = (localeName) => localeName.toLocaleLowerCase();

/**
 * By default esbuild can handle dynamic imports starting from `./` or `../`.
 * It's not the big issue, but it also creates chunks for all dynamic import targets (in our case for each locale)
 * We don't need this behavior, we have 2 variants of moment locales + 1 variant of dayjs locale + 2 targets: esm + cjs
 * So by default it results in a huge (100+) locale files generated by esbuild.
 * We have to move these locale chunks generation behavior on the Host App bundler side.
 * But also a Host App bundler may NOT work properly with dynamic imports like `import(`moment/locale/${locale}`)`
 *
 * So this plugin:
 * - handles `moment`/`dayjs` lazy locale dynamic imports like `import(`moment/locale/${locale}`)`
 * - transforms them into a set of statically analyzable imports within a switch-case statement, so all bundlers can understand them
 * - also it generates locale imports ONLY for locales that are supported by Metabase
 */
export const dynamicLocaleImportsPlugin = ({
  basePath,
  filter,
  libraryLocalePaths,
}) => {
  const nodeModulesPath = path.join(basePath, "node_modules");
  const availableLocalesGlobPath = path.join(basePath, "resources/i18n/*");

  const availableLocales = glob
    .sync(availableLocalesGlobPath)
    .map((localePath) => normalizeLocaleName(path.parse(localePath).name));

  if (!availableLocales.length) {
    throw new Error('No locales found in "resources/i18n" directory.');
  }

  const localePathsByLibrary = libraryLocalePaths.reduce(
    (acc, libraryLocalePath) => {
      const libraryLocaleGlobPath = path.join(libraryLocalePath, "*");

      const foundLocales = glob.sync(libraryLocaleGlobPath, {
        cwd: nodeModulesPath,
      });
      const filteredLocales = foundLocales.filter((localePath) => {
        const localeName = normalizeLocaleName(path.parse(localePath).name);

        return availableLocales.includes(localeName);
      });

      acc[libraryLocalePath] = filteredLocales;

      return acc;
    },
    {},
  );

  return {
    name: "dynamic-import",
    setup(build) {
      build.onLoad({ filter }, async (args) => {
        const { path: resolvePath } = args;

        let contents = await fs.readFile(resolvePath, "utf8");

        const matches = contents.matchAll(DYNAMIC_IMPORT_LOCALE_REGEX);

        let dynamicImportIndex = -1;

        for (const match of matches) {
          const [full, importPath] = match;

          const isMatchedImportPath =
            libraryLocalePaths.some((libraryLocalePath) =>
              importPath.startsWith(`\`${libraryLocalePath}`),
            ) &&
            importPath.endsWith("`") &&
            importPath.includes("${");

          if (!isMatchedImportPath) {
            continue;
          }

          const targetLibraryLocalePaths = libraryLocalePaths.find(
            (libraryLocalePath) => importPath.includes(libraryLocalePath),
          );
          const localePaths = localePathsByLibrary[targetLibraryLocalePaths];

          const caseStatements = localePaths
            .map(
              (localeImport) =>
                `case '${localeImport}': return import('${localeImport}');`,
            )
            .join("\n");

          dynamicImportIndex++;

          const adjustedContent = contents.replace(
            full,
            full.replace(
              "import",
              `${DYNAMIC_IMPORT_LOCALE_FUNCTION_NAME}${dynamicImportIndex}__`,
            ),
          );

          contents =
            `function ${DYNAMIC_IMPORT_LOCALE_FUNCTION_NAME}${dynamicImportIndex}__(path) {
              switch (path) {
                ${caseStatements}
                default:
                  return Promise.resolve().then(() => {
                    throw new Error("Unknown variable dynamic import: " + path)
                  })
              }
            }` + adjustedContent;
        }

        return dynamicImportIndex === -1 ? null : { contents, loader: "ts" };
      });
    },
  };
};
